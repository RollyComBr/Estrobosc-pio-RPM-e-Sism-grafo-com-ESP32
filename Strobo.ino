/**
 * @file main.cpp
 * @brief Firmware para um dispositivo multifuncional baseado em ESP32.
 * @author Grupo Alfa (Igor Gustavo, Nycollas Luan, Mateus Paiva, Rolly Santos)
 * @date 2023-10-27
 *
 * Este projeto implementa um dispositivo portátil com as seguintes funções:
 * - Estroboscópio digital com ajuste de FPM e fase.
 * - Tacômetro digital (RPM) usando um sensor IR.
 * - Sismógrafo/Vibrômetro usando um acelerômetro ADXL345.
 * - Lanterna.
 * - Modo de teste de hardware.
 * A interface é controlada por um display OLED, um encoder rotativo e quatro botões.
 */
 
 #include <Preferences.h>         // Biblioteca para armazenar dados na memória flash NVS (Non-Volatile Storage)
#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>
#include <Adafruit_ADXL345_U.h>
#define ENCODER_DO_NOT_USE_INTERRUPTS
#include <Encoder.h>

// ==== Configurações de Hardware ====
#define SCREEN_WIDTH 128
#define SCREEN_HEIGHT 64
#define OLED_RESET    -1
#define ENCODER_PIN_A 16
#define ENCODER_PIN_B 17
#define BUTTON_MENU   5
#define BUTTON_SET    15
#define BUTTON_DOUBLE 18
#define BUTTON_HALF   19
#define BUTTON_ENC    25
#define LED_PIN       2       // Pino do LED de alta potência para o estroboscópio/lanterna
#define SENSOR_IR_PIN 4       // Pino do sensor infravermelho para medição de RPM

Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);
Preferences prefs;  
Encoder encoder(ENCODER_PIN_A, ENCODER_PIN_B);
Adafruit_ADXL345_Unified accel = Adafruit_ADXL345_Unified();
bool adxlAvailable = false;

// ==== Imagens do dispositivo ====
const unsigned char bitmap[] PROGMEM = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x07, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x38, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x00, 0x03, 0xf8, 0x00, 0x00, 0x00, 0x00,
    0x00, 0xc0, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x00, 0x06, 0x7c, 0x00, 0x00, 0x00, 0x00,
    0x01, 0x00, 0x00, 0x60, 0x00, 0x00, 0x40, 0x00, 0x0f, 0x00, 0x0c, 0x38, 0x00, 0x00, 0x00, 0x00,
    0x02, 0x00, 0x00, 0x10, 0x00, 0x00, 0xe0, 0x00, 0x07, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x04, 0x00, 0x00, 0x08, 0x00, 0x00, 0xe0, 0x00, 0x07, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x08, 0x00, 0x00, 0x04, 0x00, 0x01, 0xe0, 0x00, 0x07, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x10, 0x0f, 0xc0, 0x02, 0x00, 0x01, 0xf0, 0x00, 0x07, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x20, 0x3f, 0xe0, 0xfa, 0x00, 0x01, 0xf0, 0x00, 0x07, 0x00, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x20, 0xf0, 0xf1, 0xf1, 0x00, 0x03, 0x78, 0x00, 0x07, 0x00, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x41, 0xe0, 0x79, 0xf1, 0x80, 0x02, 0x78, 0x00, 0x07, 0x00, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x43, 0xc0, 0x7b, 0xe0, 0x80, 0x06, 0x38, 0x00, 0x07, 0x00, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x07, 0x80, 0x3d, 0xc0, 0x80, 0x06, 0x3c, 0x00, 0x07, 0x00, 0x70, 0x00, 0x00, 0x00, 0x00, 0xf0,
    0x0f, 0x80, 0x3d, 0xc0, 0x80, 0x04, 0x3c, 0x00, 0x07, 0x03, 0xff, 0x80, 0xfc, 0x00, 0x83, 0xfc,
    0x9f, 0x00, 0x3d, 0x80, 0x40, 0x0c, 0x1c, 0x00, 0x07, 0x00, 0x78, 0x03, 0xff, 0x0f, 0x86, 0x0e,
    0x9e, 0x00, 0x1d, 0x80, 0x40, 0x0c, 0x1e, 0x00, 0x07, 0x00, 0x70, 0x0f, 0x07, 0x9f, 0x0c, 0x06,
    0x3e, 0x00, 0x1f, 0x80, 0x40, 0x18, 0x1e, 0x00, 0x07, 0x00, 0x70, 0x1e, 0x07, 0xbe, 0x0c, 0x06,
    0x3e, 0x00, 0x1f, 0x00, 0x40, 0x18, 0x0e, 0x00, 0x07, 0x00, 0x70, 0x3c, 0x03, 0xfe, 0x1c, 0x02,
    0x3c, 0x00, 0x6f, 0x00, 0x40, 0x10, 0x0f, 0x00, 0x07, 0x00, 0x70, 0x78, 0x03, 0xdc, 0x1e, 0x00,
    0x3c, 0x00, 0x6f, 0x00, 0x40, 0x30, 0x0f, 0x00, 0x07, 0x00, 0x70, 0xf8, 0x03, 0xd8, 0x0f, 0x00,
    0x7c, 0x00, 0xef, 0x00, 0x00, 0x3f, 0xff, 0x00, 0x07, 0x00, 0x70, 0xf0, 0x01, 0xd8, 0x0f, 0xc0,
    0x7c, 0x01, 0xe7, 0x80, 0x80, 0x3f, 0xff, 0x80, 0x07, 0x00, 0x71, 0xf0, 0x01, 0xf8, 0x07, 0xf0,
    0x7c, 0x03, 0xf7, 0x80, 0x80, 0x60, 0x07, 0x80, 0x07, 0x00, 0x71, 0xe0, 0x01, 0xf0, 0x03, 0xf8,
    0x3c, 0x07, 0xe7, 0x80, 0x80, 0x60, 0x03, 0xc0, 0x07, 0x00, 0x71, 0xe0, 0x02, 0xf0, 0x00, 0xfe,
    0x3e, 0x0f, 0xc3, 0xc1, 0x00, 0xc0, 0x03, 0xc0, 0x07, 0x00, 0x73, 0xe0, 0x06, 0xf0, 0x00, 0x3e,
    0x1f, 0xff, 0x03, 0xf6, 0x00, 0xc0, 0x03, 0xc0, 0x07, 0x00, 0x73, 0xc0, 0x06, 0xf0, 0x00, 0x1f,
    0x13, 0xfc, 0x01, 0xfe, 0x00, 0xc0, 0x01, 0xe0, 0x07, 0x00, 0x73, 0xc0, 0x0e, 0x70, 0x00, 0x0f,
    0x00, 0x00, 0x00, 0x04, 0x01, 0x80, 0x01, 0xe0, 0x07, 0x00, 0x71, 0xc0, 0x1f, 0x78, 0x10, 0x07,
    0x00, 0x00, 0x00, 0x08, 0x01, 0x80, 0x00, 0xe0, 0x07, 0x00, 0x71, 0xe0, 0x3e, 0x78, 0x18, 0x07,
    0x00, 0x00, 0x00, 0x10, 0x03, 0x80, 0x00, 0xf0, 0x07, 0x00, 0x71, 0xe0, 0xfc, 0x7c, 0x18, 0x06,
    0x01, 0x00, 0x00, 0x20, 0x07, 0x80, 0x00, 0xf8, 0x0f, 0x00, 0x78, 0xfb, 0xf8, 0x3e, 0x5c, 0x0e,
    0x00, 0xc0, 0x00, 0xc0, 0x1f, 0xf0, 0x07, 0xff, 0x3f, 0xe3, 0xff, 0x3f, 0xe0, 0x1f, 0x8f, 0x38,
    0x00, 0x00, 0x02, 0x00, 0x00, 0x10, 0x04, 0x00, 0x20, 0x22, 0x01, 0x00, 0x00, 0x00, 0x03, 0xe0,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

const unsigned char trofeu[] PROGMEM = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xff, 0xff, 0x80, 0x01, 0xff, 0xff, 0x80,
  0x01, 0xff, 0xff, 0x80, 0x7f, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xff, 0xfe,
  0xe1, 0xff, 0xff, 0x0e, 0xe1, 0xff, 0xff, 0x0e, 0x61, 0xff, 0xff, 0x0e, 0x70, 0xff, 0xff, 0x0e,
  0x70, 0xff, 0xfe, 0x1e, 0x78, 0xff, 0xfe, 0x1c, 0x38, 0xff, 0xfe, 0x3c, 0x3c, 0x7f, 0xfe, 0x78,
  0x1e, 0x7f, 0xfe, 0xf0, 0x0f, 0x7f, 0xfd, 0xe0, 0x07, 0xff, 0xff, 0xe0, 0x03, 0xff, 0xff, 0x80,
  0x00, 0xff, 0xff, 0x00, 0x00, 0x3f, 0xf8, 0x00, 0x00, 0x07, 0xc0, 0x00, 0x00, 0x03, 0xc0, 0x00,
  0x00, 0x03, 0xc0, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x7f, 0xfe, 0x00, 0x00, 0x7f, 0xfe, 0x00,
  0x00, 0x7f, 0xfe, 0x00, 0x00, 0x7f, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// 'SENAI_São_Paulo_logo', 128x32px
const unsigned char senai_logo [] PROGMEM = {
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xfc, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0x01, 0xff, 0xc0, 0x07, 0xf8, 0x00, 0x01, 0xc0, 0x0f, 0xe0, 0x7f, 0xf0, 0x0f, 0xff, 0x03, 0x80, 
	0xff, 0xff, 0x00, 0x01, 0xf8, 0x00, 0x01, 0xc0, 0x0f, 0xe0, 0x7f, 0xe0, 0x0f, 0xfe, 0x03, 0xff, 
	0xff, 0xfe, 0x00, 0x01, 0xf8, 0x00, 0x03, 0xc0, 0x0f, 0xe0, 0xff, 0xe0, 0x07, 0xfe, 0x03, 0xff, 
	0xff, 0xfc, 0x00, 0x00, 0xf8, 0x00, 0x03, 0xc0, 0x0f, 0xc0, 0xff, 0xc0, 0x07, 0xfe, 0x07, 0xff, 
	0xff, 0xf8, 0x0f, 0x80, 0xf0, 0x1f, 0xff, 0x80, 0x0f, 0xc0, 0xff, 0xc0, 0x07, 0xfe, 0x07, 0xff, 
	0xff, 0xf8, 0x1f, 0x80, 0xf0, 0x1f, 0xff, 0x80, 0x07, 0xc0, 0xff, 0x82, 0x07, 0xfe, 0x07, 0xff, 
	0xff, 0xf0, 0x1f, 0x80, 0xf0, 0x3f, 0xff, 0x80, 0x07, 0xc0, 0xff, 0x02, 0x07, 0xfc, 0x07, 0xff, 
	0xff, 0xf0, 0x0f, 0xff, 0xf0, 0x3f, 0xff, 0x81, 0x07, 0xc1, 0xff, 0x06, 0x03, 0xfc, 0x07, 0xff, 
	0xff, 0xf0, 0x03, 0xff, 0xe0, 0x3f, 0xff, 0x83, 0x07, 0x81, 0xfe, 0x06, 0x03, 0xfc, 0x0f, 0xff, 
	0xff, 0xf0, 0x00, 0x7f, 0xe0, 0x00, 0x0f, 0x03, 0x03, 0x81, 0xfe, 0x0f, 0x03, 0xfc, 0x0f, 0xff, 
	0xff, 0xf8, 0x00, 0x0f, 0xe0, 0x00, 0x0f, 0x03, 0x03, 0x81, 0xfc, 0x0f, 0x03, 0xf8, 0x0f, 0xff, 
	0x01, 0xfc, 0x00, 0x07, 0xe0, 0x00, 0x0f, 0x03, 0x83, 0x83, 0xf8, 0x1f, 0x03, 0xf8, 0x0f, 0x80, 
	0xff, 0xff, 0x00, 0x03, 0xe0, 0x00, 0x1f, 0x03, 0x83, 0x83, 0xf8, 0x1f, 0x03, 0xf8, 0x1f, 0xff, 
	0xff, 0xff, 0xe0, 0x03, 0xc0, 0x00, 0x1f, 0x07, 0x81, 0x03, 0xf0, 0x3f, 0x01, 0xf8, 0x1f, 0xff, 
	0xff, 0xff, 0xfc, 0x03, 0xc0, 0x7f, 0xfe, 0x07, 0x81, 0x03, 0xf0, 0x00, 0x01, 0xf8, 0x1f, 0xff, 
	0xff, 0xff, 0xfe, 0x03, 0xc0, 0xff, 0xfe, 0x07, 0x81, 0x03, 0xe0, 0x00, 0x01, 0xf0, 0x1f, 0xff, 
	0xff, 0xc0, 0xfe, 0x03, 0xc0, 0xff, 0xfe, 0x07, 0xc1, 0x07, 0xc0, 0x00, 0x01, 0xf0, 0x1f, 0xff, 
	0xff, 0xc0, 0x7e, 0x03, 0xc0, 0xff, 0xfe, 0x07, 0xc0, 0x07, 0xc0, 0x00, 0x01, 0xf0, 0x3f, 0xff, 
	0xff, 0xc0, 0x7c, 0x07, 0x80, 0xff, 0xfe, 0x0f, 0xc0, 0x07, 0x80, 0x00, 0x00, 0xf0, 0x3f, 0xff, 
	0xff, 0xc0, 0x00, 0x07, 0x80, 0x00, 0x1c, 0x0f, 0xc0, 0x07, 0x81, 0xff, 0x80, 0xf0, 0x3f, 0xff, 
	0xff, 0xe0, 0x00, 0x0f, 0x80, 0x00, 0x1c, 0x0f, 0xe0, 0x07, 0x03, 0xff, 0x80, 0xe0, 0x3f, 0xff, 
	0xff, 0xe0, 0x00, 0x1f, 0x80, 0x00, 0x3c, 0x0f, 0xe0, 0x0e, 0x03, 0xff, 0x80, 0xe0, 0x3f, 0xff, 
	0x01, 0xf8, 0x00, 0x7f, 0x80, 0x00, 0x3c, 0x1f, 0xe0, 0x0e, 0x07, 0xff, 0x80, 0xe0, 0x7f, 0x80, 
	0xff, 0xff, 0x8f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};

// --- VARIÁVEIS GLOBAIS DE ESTADO ---

// ==== Estados e enum de Modos ====
enum class Mode { HOME, FREQUENCY, RPM, LANTERN, SEISMOGRAPH, TEST, ABOUT, NUM_MODES};
Mode currentMode = Mode::HOME;
Mode selectedMode = Mode::HOME;
bool inMenu = true;
bool inSubmenu = false;
bool inEncoder = false;

// ==== Variáveis do Modo Teste ====
bool pulseActive = false;

// ==== Variáveis do Modo Estroboscópio ====

float fpm = 300; // Valor inicial de FPM
long STB_lastEncoderPos = 0;

float STB_phaseDegrees = 0.0;               // Ajuste de fase em graus
unsigned long STB_partTime = 1000000;       // Duração de meio ciclo em microssegundos
unsigned long STB_phaseDelayMicros = 0;     // Atraso de fase em microssegundos
bool STB_calc = true;                       // Indica se os cálculos precisam ser refeitos
bool STB_firstPulse = true;                 // Para aplicar a fase apenas uma vez
bool STB_outputEnabled = false;             // Controla se a saída está ativa

hw_timer_t *timer = NULL;
portMUX_TYPE STB_timerMux = portMUX_INITIALIZER_UNLOCKED;
volatile bool STB_pulseState = false;

const int minFPM = 30;                   // Limite mínimo de FPM
const int maxFPM = 40000;                 // Limite máximo de FPM
//-------------------------------------

// ==== Variáveis do Sismográfo ====
enum class SeismoState {SEISMO_HOME, SEISMO_IDLE, SEISMO_CALIB, SEISMO_CONFIG, SEISMO_MEASURE, SEISMO_RESULT};
SeismoState seismoState = SeismoState::SEISMO_HOME;
float offsetX = 0, offsetY = 0, offsetZ = 0;
float amplitude = 0, frequency = 0, magnitude = 0;
unsigned long duration = 0;
int measureTime = 10;
long lastEncoderValue = 0;
//-------------------------------------

// ==== Variáveis do RPM ====
#define TEMPO_LEITURA_RPM 1000  // em milissegundos (1 segundo)
unsigned long ultimaLeitura = 0;
int contagemPulsos = 0;
bool estadoAnterior = LOW;
float rpmValue = 0;  // Valor de RPM calculado

bool Lant_calc = false;
bool TESTE_calc = false;
float TESTE_fpm = 0;
//-------------------------------------
// ==== Temporizador ====
struct TimerMicros {
  unsigned long start;
  unsigned long duration;
  void startTimer(unsigned long d) {
    duration = d;
    start = micros();
  }
  bool isExpired() {
    return (micros() - start) >= duration;
  }
  bool isRunning() {
    return (micros() - start) < duration;
  }
};
TimerMicros msgTimer; //Pode criar quantos TimerMicros for necessário
TimerMicros fpmTest;

// ==== Função de interrupção do timer. Alterna o estado do LED e aplica o atraso de fase na primeira chamada. ====
void IRAM_ATTR onTimer() {
  static bool phaseApplied = false;
  portENTER_CRITICAL_ISR(&STB_timerMux);

  if (!STB_outputEnabled) {
    digitalWrite(LED_PIN, LOW);
    portEXIT_CRITICAL_ISR(&STB_timerMux);
    return;
  }

  if (STB_firstPulse && !phaseApplied && STB_phaseDelayMicros > 0) {
    timerAlarm(timer, STB_phaseDelayMicros, true, 0);  // Atraso de fase
    phaseApplied = true;
  } else {
    STB_pulseState = !STB_pulseState;
    digitalWrite(LED_PIN, STB_pulseState);
    timerAlarm(timer, STB_partTime, true, 0);          // Próximo intervalo
    STB_firstPulse = false;
    phaseApplied = false;
  }

  portEXIT_CRITICAL_ISR(&STB_timerMux);
}

// Atualiza os valores com base na entrada de FPM. Recalcula os tempos de ciclo e atraso de fase.
void updateValues() {
  if (STB_calc) {
    unsigned long cycleTimeMicros = 60000000UL / fpm;
    STB_partTime = cycleTimeMicros / 2;
    STB_phaseDelayMicros = (STB_phaseDegrees / 360.0) * cycleTimeMicros;
    STB_firstPulse = true;
    STB_calc = false;
  } else if (Lant_calc) {
    unsigned long cycleTimeMicros = 60000000UL / 7200;
    STB_partTime = cycleTimeMicros / 2;
    STB_phaseDelayMicros = (STB_phaseDegrees / 360.0) * cycleTimeMicros;
    STB_firstPulse = true;
  } else if (TESTE_calc) {
    unsigned long cycleTimeMicros = 60000000UL / TESTE_fpm;
    STB_partTime = cycleTimeMicros / 2;
    STB_phaseDelayMicros = (STB_phaseDegrees / 360.0) * cycleTimeMicros;
    STB_firstPulse = true;
  }
}

// ==== Ajusta o FPM multiplicando-o por um fator ====
void adjustFPM(float factor) {
  fpm = constrain(fpm * factor, minFPM, maxFPM);
}

bool checkButtonDebounce(uint8_t pin, bool &lastState, unsigned long &lastDebounceTime, unsigned long debounceDelayMicros = 200000) {
  bool currentState = digitalRead(pin);
  unsigned long now = micros();
  if (currentState == LOW && lastState == HIGH && (now - lastDebounceTime > debounceDelayMicros)) {
    lastDebounceTime = now;
    lastState = currentState;
    return true; // Botão pressionado com debounce válido
  }
  lastState = currentState;
  return false;
}

// --- FUNÇÕES DE LÓGICA ---
// ==== Grava os valores na memória ====
void updateValuesRec(){
  // Salva o FPM atual na memória não-volátil
  prefs.begin("config", false);  // Abre o namespace "config" no modo gravação
  prefs.putInt("fpm", fpm);      // Salva o valor
  prefs.end();                   // Fecha o namespace
}

// ==== Setup dos botões ====
void setupButtons(){
  pinMode(BUTTON_MENU, INPUT_PULLUP);
  pinMode(BUTTON_SET, INPUT_PULLUP);
  pinMode(BUTTON_DOUBLE, INPUT_PULLUP);
  pinMode(BUTTON_HALF, INPUT_PULLUP);
  pinMode(BUTTON_ENC, INPUT_PULLUP);
}
// ==== Setup ====
void setup() {
  // Inicializa o pino do LED
  pinMode(LED_PIN, OUTPUT);
  digitalWrite(LED_PIN, LOW);
  // Inicializa o pino do sensor IR
  pinMode(SENSOR_IR_PIN, INPUT);
  setupButtons();

  // Inicia a comunicação I2C com os pinos corretos
  Wire.begin(21, 22);  // SDA = 21, SCL = 22
  // Recupera o último FPM salvo na memória
  prefs.begin("config", true);    // Abre o namespace "config" em modo de leitura
  fpm = prefs.getInt("fpm", 30);  // Carrega 'fpm', usa 30 como padrão se não existir
  prefs.end();
  STB_calc = true;

  Serial.begin(115200);

  adxlAvailable = accel.begin();
  if (adxlAvailable) accel.setRange(ADXL345_RANGE_16_G);
  
  if (!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) {
    Serial.println(F("Falha ao iniciar OLED"));
    while (true);
  }

  // Inicializa o timer com resolução de 1us (1MHz)
  timer = timerBegin(1000000);
  timerAttachInterrupt(timer, onTimer);
  timerAlarm(timer, STB_partTime, true, 0);

  // Mostra a tela de splashAdd commentMore actions
  display.clearDisplay();
  display.drawBitmap(0, 0, bitmap, SCREEN_WIDTH, SCREEN_HEIGHT, SSD1306_WHITE);
  display.display();
  delay(2000);
  display.clearDisplay();
  display.drawBitmap(0, 20, senai_logo, 128, 32, SSD1306_WHITE);
  display.display();
  delay(2000);
  display.clearDisplay();
}

// ==== Loop principal ====
void loop() {
  handleInput();
  updateValues(); //Stroboscópio fica com a função rodando, mas não executa os leds. Apenas os contadores do timer.

  if (inMenu) {
    drawMenu();
    STB_outputEnabled=false;
    TESTE_calc = false;
    Lant_calc = false;
  } else {
    drawScreen(currentMode);
  }

  // --- MÁQUINA DE ESTADOS PRINCIPAL (EXECUÇÃO DO MODO ATUAL) ---
  if (!inMenu) {
    switch (selectedMode) {
      case Mode::FREQUENCY: {
        STB_outputEnabled=true;
        //Comandos para alterar o valor usando o Encoder
        long newPos = encoder.read() / 4;  // Dividido por 4 para reduzir sensibilidade
        if (inSubmenu) {
          int delta = newPos - STB_lastEncoderPos;
          STB_phaseDegrees = constrain(STB_phaseDegrees + delta, 0, 359) % 359;
          STB_lastEncoderPos = newPos;
          updateValuesRec();
          STB_calc = true;
        } else if (!inSubmenu) {
          int delta = newPos - STB_lastEncoderPos;
          if (inEncoder) {
            delta= delta * 10;
          }
          fpm = constrain(fpm + delta, minFPM, maxFPM);
          STB_lastEncoderPos = newPos;
          updateValuesRec();
          STB_calc = true;
        }
        break;
      }
      case Mode::RPM:{
        unsigned long agora = millis();
        bool estadoAtual = digitalRead(SENSOR_IR_PIN);
  
        // Detecta pulso (borda de subida: LOW -> HIGH)
        if (estadoAtual == HIGH && estadoAnterior == LOW) {
          contagemPulsos++;
        }
        estadoAnterior = estadoAtual;
        // A cada TEMPO_LEITURA_RPM milissegundos, calcula e imprime o RPM
        if (agora - ultimaLeitura >= TEMPO_LEITURA_RPM) {
          ultimaLeitura = agora;
          // Se há 1 marca por rotação, então: RPM = pulsos * 60
          int rpm = contagemPulsos * 60;
          rpmValue = rpm;
          // Reinicia a contagem
          contagemPulsos = 0;
        }
        break;
      }
      case Mode::LANTERN:
        STB_outputEnabled=true;
        Lant_calc = true;
        break;
      case Mode::SEISMOGRAPH:
        if (seismoState == SeismoState::SEISMO_CONFIG){
          measureTime = constrain(encoder.read() / 4, 10, 60);
        }
        break;
      case Mode::TEST: {
        static unsigned long ultimoTempo = 0;
        static float fpmAtual = 30.0;
        static const float passo = 30.0;
        static const unsigned long intervaloTeste = 100; // 2 segundos entre testes

        unsigned long agora = millis();
        if(fpmTest.isRunning()){
          if (agora - ultimoTempo >= intervaloTeste) {
            TESTE_fpm = fpmAtual;
            updateValues();
            fpmAtual += passo;
            if (fpmAtual >= maxFPM) {
              fpmAtual = 30.0; // reinicia o ciclo
            }
            ultimoTempo = agora;
          }
        } else if(fpmTest.isExpired()){
          fpmAtual=30;
          STB_outputEnabled=false;
          TESTE_calc = false;
        } else{
          STB_outputEnabled=false;
          TESTE_calc = false;
        }
        break;
      }
    }
  }
}

// ==== Tratamento de botões ====
void handleInput() {
  static bool lastMenuState = HIGH;
  static bool lastSetState  = HIGH;
  static unsigned long lastDebounceTimeMenu = 0;
  static unsigned long lastDebounceTimeSet  = 0;

  if (checkButtonDebounce(BUTTON_MENU, lastMenuState, lastDebounceTimeMenu)) {
    if (inSubmenu) {
      // Se estiver no submenu, apenas sai dele
      inSubmenu = false;
    } else if (!inMenu) {
      // Se estiver fora do menu, entrar no menu com o modo atual
      currentMode = selectedMode;
      inMenu = true;
    } else {
      currentMode = static_cast<Mode>((static_cast<int>(currentMode) + 1) % static_cast<int>(Mode::NUM_MODES));
    }
  }

  if (checkButtonDebounce(BUTTON_SET, lastSetState, lastDebounceTimeSet)) {
    if (inMenu) {
      selectedMode = currentMode;
      inMenu = false;
    } else {
      if (selectedMode == Mode::SEISMOGRAPH) {
        switch (seismoState) {
            case SeismoState::SEISMO_HOME:
              seismoState = SeismoState::SEISMO_IDLE;
              break;
            case SeismoState::SEISMO_IDLE:
              seismoState = SeismoState::SEISMO_CALIB;
              break;
            case SeismoState::SEISMO_CALIB:
              calibrateSensor();
              seismoState = SeismoState::SEISMO_CONFIG;
              break;
            case SeismoState::SEISMO_CONFIG:
              seismoState = SeismoState::SEISMO_MEASURE;
              startMeasurement();
              break;
            case SeismoState::SEISMO_RESULT:
              seismoState = SeismoState::SEISMO_HOME;
              break;
            default:
              break;
          }
      } else if (selectedMode == Mode::RPM) {
        inSubmenu = false;
        if(rpmValue>=30){
          fpm = rpmValue;    //FPM recebe o valor de RPM
          msgTimer.startTimer(2000000UL); //Inicia a contagem para exibir a mensagem de gravando por 2 segundos
        }
      } else if(selectedMode == Mode::TEST){
        STB_outputEnabled=true;
        TESTE_calc = true;
        fpmTest.startTimer(10000000UL);
      }else if(selectedMode == Mode::LANTERN || currentMode == Mode::ABOUT){
        inSubmenu = false;
      } else {
        inSubmenu = !inSubmenu;
        STB_outputEnabled=false;
      }
    }
  }

  if (checkButtonDebounce(BUTTON_DOUBLE, lastSetState, lastDebounceTimeSet)) {
    if (inMenu) {
      selectedMode = currentMode;
      inMenu = false;
    } else {
      if (selectedMode == Mode::FREQUENCY && !inSubmenu) {
        adjustFPM(0.5);
        STB_calc = true;
      }
    }
  }

  if (checkButtonDebounce(BUTTON_HALF, lastSetState, lastDebounceTimeSet)) {
    if (inMenu) {
      selectedMode = currentMode;
      inMenu = false;
    } else {
      if (selectedMode == Mode::FREQUENCY && !inSubmenu) {
        adjustFPM(2.0);
        STB_calc = true;
      }
    }
  }

  if (checkButtonDebounce(BUTTON_ENC, lastMenuState, lastDebounceTimeMenu)) {
    inEncoder = !inEncoder;
    if (inEncoder) {
      //FAZ
    } else {
      //NÃO FAZ
    }
  }
}

// ==== Tela do Menu ====
void drawMenu() {
  display.clearDisplay();
  display.setTextSize(1);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(0, 0);
  display.println("Selecione o modo:");
  display.setTextSize(2);
  display.setCursor(0, 20);
  display.println(getModeName(currentMode));
  display.setTextSize(1);
  display.setCursor(0, 56);
  display.println("MENU=Prox SET=Entrar");
  display.display();
}

// ==== Tela de cada Modo ====
void drawScreen(Mode mode) {
  // Limita a taxa de atualização para evitar flickering e consumo de CPU
  static unsigned long lastUpdate = 0;
  if (millis() - lastUpdate < 50) return;  // Atualiza a cada 50ms (20 FPS)
  lastUpdate = millis();

  display.clearDisplay();
  display.setTextSize(1);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(0, 0);
  display.println(getModeName(mode));
  display.drawLine(0, 10, SCREEN_WIDTH, 10, SSD1306_WHITE);
  display.setCursor(0, 14);

  if (currentMode == Mode::RPM) {
    display.print("RPM: ");
    display.print((int)rpmValue);
    display.setCursor(90, 14);
    display.print("S: ");
    display.print(rpmValue > 0 ? "OK" : "X");
    display.setCursor(0, 26);
    display.print(msgTimer.isRunning() ? "Gravando FPM..." : "Gravar use SET");
    display.setCursor(0, 56);
    display.println("Menu=Voltar SET=Gravar");

  } else if (currentMode == Mode::ABOUT) {
    display.println("Grupo Alfa: ");
    display.println("Igor Gustavo");
    display.println("Nycollas Luan");
    display.println("Mateus Paiva");
    display.println("Rolly Santos");
    display.drawBitmap(90, 15, trofeu, 32, 32, SSD1306_WHITE);
    display.setCursor(0, 56);
    display.println("alfasweb.com.br");
  } else if (currentMode == Mode::TEST) {
    display.print(fpmTest.isRunning() ? "Testando" : "Testar");
    display.setCursor(0, 56);
    display.println(fpmTest.isRunning() ? "Aguarde..." : "SET=Iniciar Teste");
  } else if (currentMode == Mode::LANTERN) {
    display.print("LANTERNA");
    display.setCursor(0, 56);
    display.println("MENU=Voltar");
  } else if (currentMode == Mode::FREQUENCY) {
    display.setTextSize(2);
    display.setCursor(0, 14);
    display.print((int)fpm);
    display.setTextSize(1);
    display.setCursor(70, 22);
    display.print("FPM");
    display.setCursor(0, 34);
    display.print("Hz:  ");
    display.print(fpm / 60.0, 2);
    display.setCursor(0, 46);
    display.print("Fase: ");
    display.print(STB_phaseDegrees);
    display.print((char)247);
    if(inSubmenu){
      display.setCursor(80, 46);
      display.println("<");
      display.setCursor(0, 56);
      display.println(">>Editar Phase");
    }
  } else if (currentMode == Mode::SEISMOGRAPH){
    if (adxlAvailable){
      switch (seismoState) {
        case SeismoState::SEISMO_HOME:
          display.println("Clique SET para iniciar");
          break;
        case SeismoState::SEISMO_IDLE:
          display.println("Coloque sobre o motor para calibrar");
          break;
        case SeismoState::SEISMO_CALIB:
          display.println("Calibrando...");
          break;
        case SeismoState::SEISMO_CONFIG:
          display.println("Selecione o tempo:");
          display.print(measureTime);
          display.println(" s");
          break;
        case SeismoState::SEISMO_MEASURE:
          display.println("Medindo...");
          break;
        case SeismoState::SEISMO_RESULT:
          display.println("RESULTADO:");
          display.print("Dur: "); display.print(duration); display.println("s");
          display.print("Amp: "); display.println(amplitude, 2);
          display.print("Freq: "); display.println(frequency, 2);
          display.print("Mag: "); display.println(magnitude, 2);
          break;
      }
    }else{
      display.println("Sensor indisponível");
    }
  }

  display.display();
}

// ==== Retorna nome do modo atual ====
const char* getModeName(Mode mode) {
  switch (mode) {
    case Mode::HOME: return "Principal";
    case Mode::FREQUENCY: return "Estroboscopio";
    case Mode::RPM: return "RPM";
    case Mode::LANTERN: return "Lanterna";
    case Mode::SEISMOGRAPH: return "Sismografo";
    case Mode::TEST: return "Teste";
    case Mode::ABOUT: return "Sobre";
  }
}

void calibrateSensor() {
  sensors_event_t event;
  long sx = 0, sy = 0, sz = 0;
  const int samples = 100;
  unsigned long lastSample = 0;
  for (int i = 0; i < samples; ) {
    if (micros() - lastSample >= 10000) {  // 10 ms
      lastSample = micros();
      accel.getEvent(&event);
      sx += event.acceleration.x;
      sy += event.acceleration.y;
      sz += event.acceleration.z;
      i++;
    }
  }
  offsetX = sx / (float)samples;
  offsetY = sy / (float)samples;
  offsetZ = sz / (float)samples;
}

void startMeasurement() {
  sensors_event_t event;
  unsigned long startMillis = millis();
  unsigned long durationMs = measureTime * 1000;
  float maxAmplitude = 0;

  unsigned long lastSample = 0;
  while (millis() - startMillis < durationMs) {
    if (micros() - lastSample >= 10000) {  // 10 ms
      lastSample = micros();
      accel.getEvent(&event);
      float ax = event.acceleration.x - offsetX;
      float ay = event.acceleration.y - offsetY;
      float az = event.acceleration.z - offsetZ;
      float amp = sqrt(ax * ax + ay * ay + az * az);
      if (amp > maxAmplitude) maxAmplitude = amp;
    }
  }

  amplitude = maxAmplitude;
  frequency = 0; // Pode ser implementado com contagem de picos
  magnitude = log10(amplitude + 1) * 3.0; // Exemplo simbólico
  duration = measureTime;
  seismoState = SeismoState::SEISMO_RESULT;
}
